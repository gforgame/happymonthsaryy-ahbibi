<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Glowing Falling Words â€” Galaxy</title>
  <style>
    :root {
      --accent: #8ff0ff;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      font-family: Inter, system-ui, Arial;
      overflow: hidden;
    }
    canvas {
      display: block;
      position: fixed;
      inset: 0;
      z-index: 0;
    }
    #errorOverlay {
      position: fixed;
      inset: 0;
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.7));
      color: #fff;
      padding: 20px;
      text-align: center;
    }
    #errorOverlay .card {
      max-width: 520px;
      background: rgba(12, 12, 20, 0.6);
      border-radius: 10px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }
    /* Nebula fade overlay and countdown */
    #nebulaFade {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9999;
      background: rgba(0,0,0,0);
      transition: background 0.2s linear;
      mix-blend-mode: normal;
    }
    #nebulaCountdown {
      position: fixed;
      left: 50%;
      top: 10%;
      transform: translateX(-50%);
      z-index: 10000;
      color: #ffffff;
      font-family: Inter, system-ui, Arial;
      font-size: 28px;
      padding: 8px 14px;
      border-radius: 8px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(4px);
      display: none;
    }
    #errorOverlay pre {
      background: rgba(255, 255, 255, 0.04);
      padding: 8px;
      border-radius: 6px;
      color: #fff;
      text-align: left;
    }
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="errorOverlay">
    <div class="card">
      <h2>Loading...</h2>
      <p>Initializing Three.js scene...</p>
    </div>
  </div>

  <!-- Three.js from CDN -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

  <script>
    // Error overlay
    const errorOverlay = document.getElementById('errorOverlay');

    function hideOverlay() {
      if (errorOverlay) {
        errorOverlay.classList.add('hidden');
      }
    }

    function showError(msg) {
      console.error(msg);
      if (errorOverlay) {
        errorOverlay.classList.remove('hidden');
        const card = errorOverlay.querySelector('.card');
        if (card) {
          card.innerHTML = `<h2>Error</h2><p>${msg}</p>`;
        }
      }
    }

    // Global error handlers
    window.addEventListener('error', (ev) => {
      console.error('Runtime error', ev.error || ev.message);
      showError((ev.error && ev.error.message) || ev.message);
    });

    window.addEventListener('unhandledrejection', (ev) => {
      console.error('Unhandled promise rejection', ev.reason);
      showError(String(ev.reason));
    });

    try {
      // Three.js scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000005);

      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(0, 0, 80);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.position = 'fixed';
      renderer.domElement.style.inset = '0';
      renderer.domElement.style.zIndex = '0';
      document.body.appendChild(renderer.domElement);

      // Simple camera controls (pan/zoom via mouse drag and scroll)
      class SimpleOrbitControls {
        constructor(camera, domElement) {
          this.camera = camera;
          this.domElement = domElement;
          this.minDistance = 20;
          this.maxDistance = Infinity;
          this.enableDamping = true;
          this.dampingFactor = 0.08;
          this.enablePan = true;
          this.autoRotate = false;

          this.theta = 0;
          this.phi = Math.PI / 2;
          this.radius = 80;
          this.tilt = 0; // roll angle for tilt gestures
          this.panX = 0;
          this.panY = 0;
          this.velocityX = 0;
          this.velocityY = 0;
          this.enabled = true;

          this.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
          this.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
          this.domElement.addEventListener('mouseup', (e) => this.onMouseUp(e));
          // touch support: single-finger drag to rotate, two-finger pinch to zoom
          this.domElement.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
          this.domElement.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
          this.domElement.addEventListener('touchend', (e) => this.onTouchEnd(e));
          this.domElement.addEventListener('wheel', (e) => this.onMouseWheel(e));

          this.isDragging = false;
          this.previousMousePosition = { x: 0, y: 0 };
        }

        onMouseDown(e) {
          this.isDragging = true;
          this.previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        onMouseMove(e) {
          if (!this.isDragging) return;
          const dx = e.clientX - this.previousMousePosition.x;
          const dy = e.clientY - this.previousMousePosition.y;
          this.theta -= dx * 0.005;
          this.phi += dy * 0.005;
          this.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.phi));
          this.previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        onMouseUp(e) {
          this.isDragging = false;
        }

        // Touch handlers
        onTouchStart(e) {
          if (!e.touches) return;
          if (e.touches.length === 1) {
            // treat as single-finger drag
            this.isDragging = true;
            this.previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.touches.length === 2) {
            // pinch start
            this.isDragging = false;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            this._prevTouchDist = Math.hypot(dx, dy);
            // store previous positions for both touches to detect same-direction swipe (tilt)
            this._prevTouchPositions = [
              { x: e.touches[0].clientX, y: e.touches[0].clientY },
              { x: e.touches[1].clientX, y: e.touches[1].clientY },
            ];
            // store mid-point for optional two-finger rotate/pan
            this._prevTouchMid = { x: (e.touches[0].clientX + e.touches[1].clientX) / 2, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 };
          }
        }

        onTouchMove(e) {
          if (!e.touches) return;
          if (e.touches.length === 1 && this.isDragging) {
            e.preventDefault();
            const dx = e.touches[0].clientX - this.previousMousePosition.x;
            const dy = e.touches[0].clientY - this.previousMousePosition.y;
            this.theta -= dx * 0.005;
            this.phi += dy * 0.005;
            this.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.phi));
            this.previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.touches.length === 2) {
              e.preventDefault();
              // compute individual touch movement deltas
              const prev = this._prevTouchPositions || [ { x: e.touches[0].clientX, y: e.touches[0].clientY }, { x: e.touches[1].clientX, y: e.touches[1].clientY } ];
              const dx0 = e.touches[0].clientX - prev[0].x; const dy0 = e.touches[0].clientY - prev[0].y;
              const dx1 = e.touches[1].clientX - prev[1].x; const dy1 = e.touches[1].clientY - prev[1].y;
              // if both fingers move in roughly same direction, interpret as tilt (roll)
              const sameDirection = (Math.sign(dx0) === Math.sign(dx1) && Math.sign(dy0) === Math.sign(dy1) && Math.abs(dx0 - dx1) < 30 && Math.abs(dy0 - dy1) < 30);
              if (sameDirection) {
                // average horizontal movement controls roll
                const avgDx = (dx0 + dx1) / 2;
                this.tilt += avgDx * 0.004; // tune sensitivity
              } else {
                // treat as pinch zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.hypot(dx, dy);
                if (this._prevTouchDist) {
                  const delta = this._prevTouchDist - dist;
                  this.radius += delta * 0.12;
                  this.radius = Math.max(this.minDistance, Math.min(this.maxDistance || Infinity, this.radius));
                }
                this._prevTouchDist = dist;
              }
              // update stored positions for next move
              this._prevTouchPositions = [ { x: e.touches[0].clientX, y: e.touches[0].clientY }, { x: e.touches[1].clientX, y: e.touches[1].clientY } ];
              // update mid-point
              this._prevTouchMid = { x: (e.touches[0].clientX + e.touches[1].clientX) / 2, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 };
          }
        }

        onTouchEnd(e) {
          this.isDragging = false;
          this._prevTouchDist = null;
          this._prevTouchMid = null;
        }

        onMouseWheel(e) {
          e.preventDefault();
          this.radius += e.deltaY * 0.05;
          this.radius = Math.max(this.minDistance, Math.min(this.maxDistance || Infinity, this.radius));
        }

        update() {
          if (!this.enabled) return;
          const x = this.radius * Math.sin(this.phi) * Math.cos(this.theta) + this.panX;
          const y = this.radius * Math.cos(this.phi) + this.panY;
          const z = this.radius * Math.sin(this.phi) * Math.sin(this.theta);
          this.camera.position.set(x, y, z);
          // apply roll/tilt by adjusting camera.up before looking at target
          this.camera.up.set(Math.sin(this.tilt), Math.cos(this.tilt), 0);
          this.camera.lookAt(this.panX, this.panY, 0);
        }
      }

      // Initialize simple controls
      const controls = new SimpleOrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enablePan = true;
      controls.minDistance = 20;
      controls.maxDistance = 300;
      // Reset camera to face directly at the canvas from the front
      controls.theta = Math.PI / 2; // face forward (0, 0, 80)
      controls.phi = Math.PI / 2; // level with center
      controls.radius = 80;
      controls.update(); // apply the initial position

      // Starfield
      function makeStarfield(count = 2500) {
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
          const r = 300;
          const x = (Math.random() - 0.5) * r;
          const y = (Math.random() - 0.5) * r * 0.6;
          const z = (Math.random() - 0.5) * r;
          positions[i * 3] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;
          const c = 0.6 + Math.random() * 0.4;
          colors[i * 3] = c;
          colors[i * 3 + 1] = c;
          colors[i * 3 + 2] = 1.0;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const mat = new THREE.PointsMaterial({
          size: 0.9,
          vertexColors: true,
          transparent: true,
          opacity: 0.9,
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);
      }
      makeStarfield(2500);

      // Nebula (replaced: large inside-facing sphere that surrounds camera)
      let nebulaSphere = null;
      // world position (far away) indicating the bright center direction on the nebula
      const nebulaCenter = new THREE.Vector3(0, 10, 1000);
      // Overlay DOM elements for fade and countdown
      const nebulaFadeEl = document.createElement('div');
      nebulaFadeEl.id = 'nebulaFade';
      document.body.appendChild(nebulaFadeEl);
      const nebulaCountdownEl = document.createElement('div');
      nebulaCountdownEl.id = 'nebulaCountdown';
      document.body.appendChild(nebulaCountdownEl);

      function makeNebula() {
        const size = 2048;
        const cvs = document.createElement('canvas');
        cvs.width = cvs.height = size;
        const ctx = cvs.getContext('2d');

        // Draw a soft radial nebula: bright center with colored glow fading to transparent
        const cx = size * 0.5;
        const cy = size * 0.5;
        const grad = ctx.createRadialGradient(cx, cy, 20, cx, cy, size * 0.6);
        grad.addColorStop(0, 'rgba(140,100,220,0.95)');
        grad.addColorStop(0.25, 'rgba(100,140,220,0.6)');
        grad.addColorStop(0.5, 'rgba(70,100,180,0.35)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, size, size);

        // subtle rim/highlight
        ctx.globalCompositeOperation = 'lighter';
        const rim = ctx.createRadialGradient(cx * 0.55, cy * 0.45, 10, cx, cy, size * 0.7);
        rim.addColorStop(0, 'rgba(200,160,255,0.06)');
        rim.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = rim;
        ctx.fillRect(0, 0, size, size);

        const tex = new THREE.CanvasTexture(cvs);
        tex.encoding = THREE.sRGBEncoding;

        // Large sphere that the camera sits inside of (use BackSide so texture is visible from inside)
        const radius = 900;
        const geo = new THREE.SphereGeometry(radius, 48, 32);
        const mat = new THREE.MeshBasicMaterial({
          map: tex,
          side: THREE.BackSide,
          transparent: true,
          depthWrite: false,
        });
        nebulaSphere = new THREE.Mesh(geo, mat);
        // Rotate so the bright spot faces +Z in world space (initial camera faces -Z)
        nebulaSphere.rotation.y = Math.PI;
        nebulaSphere.position.set(0, 0, 0);
        scene.add(nebulaSphere);

        // Place the logical nebula center far out along +Z (matches rotation)
        nebulaCenter.set(0, 10, radius - 40);
      }
      makeNebula();

      // State for detection/timer/approach
      let nebulaSeenStarted = false;
      let nebulaCountdownStart = 0;
      const nebulaCountdownSeconds = 8; // 8 second timer when nebula is first seen
      let approachingNebula = false;
      let approachStart = 0;
      const approachDuration = 6000; // ms for the slow approach into nebula
      // store camera start position for cinematic lerp
      let approachFrom = new THREE.Vector3();
      let approachTo = new THREE.Vector3();
      // Fade color (matches nebula center color used in canvas)
      const nebulaFadeRGB = { r: 140, g: 100, b: 220 };

      // Words and sprites
      let sprites = [];

      // Hard-coded words list
      const WORDS = [
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'my baby',
        'my love',
        'my ahbibi',
        'my soulmate',
        'ðŸ’«',
        'my darling',
        'my pookie wookie',
        'âœ¨',
        'ðŸŒ™',
        'my pangga',
        'my palangga',
        'my langga',
        'my asawa',
        'my sayang',
        'my lalove',
        'my palalove',
        'my lovelove',
        'my baby girl',
        'mi amor',
        'my loml',
        'my sweetheart',
        'my everything',
        'my person',
        'my one and only',
        'my forever',
        'my heart',
        'my treasure',
        'my joy',
        'my happiness',
        'my world',
        'my home',
        'my rest',
        'my comfort',
        'my happiness',
        'my peace',
        'ðŸ’–',
        'ðŸ’˜',
        'ðŸ’',
        'ðŸ’ž',
        'ðŸ’•',
        'my safe place',
        'my answered prayer',
        'my one and only love',
        'my one and only',
        'my pretty girl',
        'my wife',
        'my whole world',
        'my universe',
        'my queen',
        'my princess',
        'my heart',
        'im here for you',
        'im here',
        'im right here with you',
        'you have me always',
        'i love you sooosososoooo much always forever!!!',
        'you are my one and only always forever',
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'i love youuu my pretty babyyy i hope you have a nice gentle day <3',
        'my baby',
        'my love',
        'my ahbibi',
        'my soulmate',
        'ðŸ’«',
        'my darling',
        'my pookie wookie',
        'âœ¨',
        'ðŸŒ™',
        'my pangga',
        'my palangga',
        'my langga',
        'my asawa',
        'my sayang',
        'my lalove',
        'my palalove',
        'my lovelove',
        'my baby girl',
        'mi amor',
        'my loml',
        'my sweetheart',
        'my everything',
        'my person',
        'my one and only',
        'my forever',
        'my heart',
        'my treasure',
        'my joy',
        'my happiness',
        'my world',
        'my home',
        'my rest',
        'my comfort',
        'my happiness',
        'my peace',
        'ðŸ’–',
        'ðŸ’˜',
        'ðŸ’',
        'ðŸ’ž',
        'ðŸ’•',
        'my safe place',
        'my answered prayer',
        'my one and only love',
        'my one and only',
        'my pretty girl',
        'my wife',
        'my whole world',
        'my universe',
        'my queen',
        'my princess',
        'my heart',
        'im here for you',
        'im here',
        'im right here with you',
        'you have me always',
        'i love you sooosososoooo much always forever!!!',
        'you are my one and only always forever',
        'ðŸ’–',
        'ðŸ’˜',
        'ðŸ’',
        'ðŸ’ž',
        'ðŸ’•',
        'ðŸ’–',
        'ðŸ’˜',
        'ðŸ’',
        'ðŸ’ž',
        'ðŸ’•',
        'ðŸ’–',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’–',
        'ðŸ’˜',
        'ðŸ’',
        'ðŸ’ž',
        'ðŸ’•',
        'ðŸ’–',
        'ðŸ’˜',
        'ðŸ’',
        'ðŸ’ž',
        'ðŸ’•',
        'ðŸ’–',
        'ðŸ’—',
        'ðŸ’—',
        'ðŸ’—',
        'i believe in you every single day babyy',
        'im so proud of you my love',
        'you are amazing and wonderful',
        'go through your day knowing youre lovedðŸ«‚ supportedðŸ«‚ and held closeðŸ«‚ alwaysðŸ«‚ðŸ’—ðŸ’—',
        'im right here cheering for youðŸ˜˜ðŸ˜˜ðŸ˜˜ðŸ˜˜ðŸ˜˜',
        'my beautiful girl',



      ];

      function makeTextSprite(text, opts = {}) {
        const font = opts.font || '40px Arial';
        const padding = opts.padding ?? 60;
        const color = opts.color || '#ffffff';
        const glow = opts.glow || '#7af0ff';

        // Measure text using a temporary context
        const measureCanvas = document.createElement('canvas');
        const mctx = measureCanvas.getContext('2d');
        mctx.font = font;
        const metrics = mctx.measureText(text);
        const w = Math.ceil(metrics.width) + padding * 2;
        const h = Math.ceil(parseInt(font, 10)) + padding * 2;

        // Prevent creating canvases larger than the GPU max texture size which causes
        // rendering issues (black squares) on some devices. Scale the drawn content
        // down to fit within renderer.capabilities.maxTextureSize.
        const maxTex = (renderer && renderer.capabilities && renderer.capabilities.maxTextureSize) || 4096;
        const scaleFactor = Math.min(1, maxTex / Math.max(w, h));

        const canvasW = Math.max(4, Math.floor(w * scaleFactor));
        const canvasH = Math.max(4, Math.floor(h * scaleFactor));
        const cvs = document.createElement('canvas');
        cvs.width = canvasW;
        cvs.height = canvasH;
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0, 0, canvasW, canvasH);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Use a scaled font so the drawn result fits into the clamped canvas size
        const baseFontSize = parseInt(font, 10) || 40;
        const fontFamily = String(font).replace(/^\s*\d+px\s*/, '');
        const scaledFontSize = Math.max(8, Math.floor(baseFontSize * scaleFactor));
        ctx.font = `${scaledFontSize}px ${fontFamily}`;

        // Scale shadow/glow to match the reduced resolution
        const blurLarge = Math.max(2, Math.floor(120 * scaleFactor));
        const blurMid = Math.max(1, Math.floor(60 * scaleFactor));
        const blurSmall = Math.max(1, Math.floor(30 * scaleFactor));

        // Draw triple shadow glow (largest first for additive feel)
        ctx.shadowColor = 'rgba(255, 51, 102, 0.8)';
        ctx.shadowBlur = blurLarge;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.fillStyle = color;
        ctx.fillText(text, canvasW / 2, canvasH / 2);

        ctx.shadowColor = 'rgba(233, 30, 99, 0.6)';
        ctx.shadowBlur = blurMid;
        ctx.fillText(text, canvasW / 2, canvasH / 2);

        ctx.shadowColor = 'rgba(194, 24, 91, 0.4)';
        ctx.shadowBlur = blurSmall;
        ctx.fillText(text, canvasW / 2, canvasH / 2);

        ctx.shadowColor = 'transparent';
        ctx.lineWidth = Math.max(1, Math.round(2 * scaleFactor));
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.strokeText(text, canvasW / 2, canvasH / 2);

        const texture = new THREE.CanvasTexture(cvs);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.needsUpdate = true;
        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          depthTest: true,
          blending: THREE.AdditiveBlending,
        });
        const sprite = new THREE.Sprite(material);
        // Keep sprite world size consistent by using the original (unclamped) dimensions
        const outScale = opts.scale || 0.09;
        sprite.scale.set((w * outScale) / 2, (h * outScale) / 2, 1);
        return sprite;
      }


      function spawnWords(list) {
        sprites.forEach((s) => {
          scene.remove(s.obj);
          if (s.obj.material.map) s.obj.material.map.dispose();
          s.obj.material.dispose();
        });
        sprites = [];
        const count = list.length;
        for (let i = 0; i < count; i++) {
          const text = list[i].trim();
          if (!text) continue;
          const spr = makeTextSprite(text, {
            font: '56px system-ui, Arial',
            glow: '#ff1493',
            scale: 0.08,
          });
          spr.position.x = (Math.random() - 0.5) * 180;
          spr.position.y = 80 + Math.random() * 240;
          spr.position.z = (Math.random() - 0.5) * 100;
          scene.add(spr);
          sprites.push({
            obj: spr,
            // moderate base speed: between ~0.4 and ~1.0 (faster than before)
            speed: 0.4 + Math.random() * 0.6,
            sway: Math.random() * 0.2 + 0.05,
            baseX: spr.position.x,
          });
        }
      }

      spawnWords(WORDS);

      // Animation loop
      let last = performance.now();
      function animate() {
        requestAnimationFrame(animate);
        const now = performance.now();
        const dt = (now - last) / 16.666;
        last = now;

        const spdFactor = 1.0;
        sprites.forEach((s) => {
          // global multiplier increased to speed up descent a bit
          s.obj.position.y -= s.speed * spdFactor * dt * 0.6;
          s.obj.position.x =
            s.baseX + Math.sin(now * 0.001 * s.sway) * (2 + s.sway * 2);
          s.obj.material.opacity = 0.95;
          if (s.obj.position.y < -140) {
            s.obj.position.y = 180 + Math.random() * 60;
            s.baseX = (Math.random() - 0.5) * 180;
            s.obj.position.z = (Math.random() - 0.5) * 120;
          }
        });

        // Detect when the nebula bright center enters camera's forward view
        if (nebulaSphere && !nebulaSeenStarted && !approachingNebula) {
          const camDir = new THREE.Vector3();
          camera.getWorldDirection(camDir);
          const toNeb = new THREE.Vector3().copy(nebulaCenter).sub(camera.position).normalize();
          const angle = camDir.angleTo(toNeb);
          // if within ~14 degrees (0.24 rad) start the countdown
          if (angle < 0.25) {
            nebulaSeenStarted = true;
            nebulaCountdownStart = now;
            nebulaCountdownEl.style.display = 'block';
          }
        }

        // Countdown UI update and starting approach
        if (nebulaSeenStarted && !approachingNebula) {
          const elapsed = (now - nebulaCountdownStart) / 1000;
          const remaining = Math.max(0, nebulaCountdownSeconds - elapsed);
          nebulaCountdownEl.textContent = `Entering nebula in ${Math.ceil(remaining)}s`;
          if (elapsed >= nebulaCountdownSeconds) {
            // begin approach
            approachingNebula = true;
            approachStart = now;
            approachFrom.copy(camera.position);
            // move slightly inside the nebula center to create an "entering" effect
            approachTo.copy(nebulaCenter);
            // disable user orbit controls during the cinematic
            controls.enabled = false;
            nebulaCountdownEl.style.display = 'none';
          }
        }

        // If approaching, animate camera forward and fade to nebula color
        if (approachingNebula) {
          const t = Math.min(1, (now - approachStart) / approachDuration);
          // smoothstep easing
          const ease = t * t * (3 - 2 * t);
          // move camera toward target
          camera.position.lerpVectors(approachFrom, approachTo, ease);
          camera.lookAt(nebulaCenter);

          // fade overlay to nebula color
          const a = ease; // alpha follows easing
          nebulaFadeEl.style.background = `rgba(${nebulaFadeRGB.r}, ${nebulaFadeRGB.g}, ${nebulaFadeRGB.b}, ${a})`;

          // when complete, redirect to thispage.html
          if (t >= 1) {
            // small timeout to ensure final frame rendered with full fade
            setTimeout(() => {
              window.location.href = 'thispage.html';
            }, 80);
          }
        }

        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Handle resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Hide the loading overlay
      hideOverlay();
    } catch (err) {
      showError('Failed to initialize: ' + err.message);
      console.error(err);
    }
  </script>
</body>
</html>
